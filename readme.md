# **Базовые команды в консоли**


## **Навигация..**
* pwd (от англ. print working directory, «показать рабочую папку») — покажи, в какой я папке;..
* ls (от англ. list directory contents, «отобразить содержимое директории») — покажи файлы и папки в текущей папке;..
* ls -a — покажи также скрытые файлы и папки, названия которых начинаются с символа .;..
* cd first-project (от англ. change directory, «сменить директорию») — перейди в папку first-project;..
* cd first-project/html — перейди в папку html, которая находится в папке first-project;..
* cd .. — перейди на уровень выше, в родительскую папку;..
* cd ~ — перейди в домашнюю директорию (/Users/Username);..
* cd / — перейди в корневую директорию.


## **Работа с файлами и папками..**
### *Создание*..
* touch index.html *(англ. touch, «коснуться»)* — создай файл index.html в текущей папке;..
* touch index.html style.css script.js — если нужно создать сразу несколько файлов, можно напечатать их имена в одну строку через пробел;..
* mkdir second-project *(от англ. make directory, «создать директорию»)* — создай папку с именем second-project в текущей папке...
### *Копирование и перемещение*..
* cp file.txt ~/my-dir *(от англ. copy, «копировать»)* — скопируй файл в другое место;..
* mv file.txt ~/my-dir *(от англ. move, «переместить»)* — перемести файл или папку в другое место...
### *Чтение*..
cat file.txt *(от англ. concatenate and print, «объединить и распечатать»)* — распечатай содержимое текстового файла file.txt.
### *Удаление*..
* rm about.html *(от англ. remove, «удалить»)* — удали файл about.html;..
* rmdir images *(от англ. remove directory, «удалить директорию»)* — удали папку images;..
* rm -r second-project *(от англ. remove, «удалить» + recursive, «рекурсивный»)* — удали папку second-project и всё, что она содержит.


## **генерация SSH ключа..**
* ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub".. 
* ssh-keygen -t ed25519 -C "электронная почта, к которой привязан ваш аккаунт на GitHub"..
Нужно роверить, что ключи действительно сгенерировались. Для этого необходимо вызвать команду - (ls -a ~/.ssh)



## **Инструкция по связыванию SSH-ключа и GitHub-аккаунта..**
1. После выполнения команды ssh-keygen в директории ~/.ssh будет создано два файла — id_ed25519 и id_ed25519.pub (или id_rsa и id_rsa.pub — в зависимости от того, какой алгоритм вы использовали):
* id_ed25519/id_rsa — приватный ключ (файл без .pub в конце). Ни в коем случае не копируйте его и не делитесь им...
* id_ed25519.pub/id_rsa.pub — публичный ключ (на это указывает расширение .pub)...
Скопируйте содержимое файла с публичным ключом в буфер обмена.
"#" скопировать содержимое ключа в буфер обмена:..
clip < ~/.ssh/id_rsa.pub..
"#" для ed25519:..
clip < ~/.ssh/id_ed25519.pub..
Если clip не сработает, выведите содержимое файла с помощью cat ~/.ssh/id_rsa.pub или cat ~/.ssh/id_ed25519.pub и скопируйте вывод в буфер обмена из консоли...
Далее добавляем ключа на github(в разделе settings).


## **Связываем локальный и удалённый репозитории..**
Откройте консоль, перейдите в каталог локального репозитория и введите команду git remote add (от англ. remote — «удалённый» и add — «добавить»)...
git remote add origin git@github.com:%ИМЯ_АККАУНТА%/first-project.git
Команде необходимо передать два параметра: имя удалённого репозитория и его URL. В качестве имени используйте слово origin. А URL вы скопировали со страницы удалённого репозитория...
Убедиться, что репозитории связаны, — git remote -v..
$ git remote -v
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (fetch)
origin    git@github.com:%ИМЯ_АККАУНТА%/%ИМЯ-ПРОЕКТА%.git (push) 


## **Синхронизируем локальный и удалённый репозитории..**
Изначально необходимо подготовить файлы с помощью git add и закоммитить их с комментарием командой git commit -m.
В первый раз эту команду нужно вызвать с флагом -u и параметрами origin (имя удалённого репозитория) и main или master (название текущей ветки). Флаг -u свяжет локальную ветку с одноимённой удалённой...
$ git push -u origin main # Если команда приведёт к ошибке, попробуйте 
                          # заменить main на master...
В дальнейшем при работе с удалённым репозиторием флаг -u можно опустить и писать просто git push.


## **Хеш — идентификатор коммита..**
* Git преобразует информацию о коммитах с помощью алгоритма SHA-1 и для каждого из них рассчитывает уникальный идентификатор — хеш...
* Хеш — основной идентификатор коммита и позволяет узнать его автора, дату и содержимое закоммиченных файлов...
* Все хеши, а также таблицу соответствий хеш → информация о коммите Git хранит в папке .git...


## **Исследуем лог..**
После вызова git log появляется список коммитов...
Элементы, из которых состоит описание:
* строка из цифр и латинских букв после слова commit — это хеш коммита;..
* Author — имя автора и его электронная почта;..
* Date — дата и время создания коммита;..
* в конце находится сообщение коммита...
### **Получить сокращённый лог — git log --oneline..**
Сокращённый лог полезен, если в репозитории уже много коммитов — например, сотни или тысячи. В этом случае можно быстро найти нужный по описанию..
Сокращённый хеш (то есть первые несколько символов полного) можно использовать точно так же, как и полный. Для этого команда git log --oneline автоматически подбирает такую длину сокращённых хешей, чтобы они были уникальными в пределах репозитория и Git всегда мог понять, о каком коммите идёт речь...
* Можно вызвать не только полный лог, но и сокращённый — это делается командой git log --oneline...
* В сокращённом логе выводятся сокращённые хеши — их можно использовать точно так же, как и полные.


## **HEAD — всему голова..**
Файл HEAD (англ. «голова», «головной») — один из служебных файлов папки .git. Он указывает на коммит, который сделан последним (то есть на самый новый)...
Внутри HEAD — ссылка на служебный файл: refs/heads/master (или refs/heads/main в зависимости от названия ветки). Если заглянуть в этот файл, можно увидеть хеш последнего коммита...
Когда вы делаете коммит, Git обновляет refs/heads/master — записывает в него хеш последнего коммита. Получается, что HEAD тоже обновляется, так как ссылается на refs/heads/master.
При работе с Git указатель HEAD используется довольно часто. Мы уже упоминали, что многие команды Git принимают в качестве параметра хеш коммита. Если нужно передать последний коммит, то вместо его хеша можно просто написать слово HEAD — Git поймёт, что вы имели в виду последний коммит...
* В числе прочих файлов в папке .git есть служебный файл HEAD. Он указывает на самый свежий коммит...
* Вместо хеша последнего коммита можно написать слово HEAD — Git вас поймёт.


## **Статусы файлов в Git..**
### **Статусы untracked/tracked, staged и modified..**
* untracked (англ. «неотслеживаемый»)..
Мы говорили, что новые файлы в Git-репозитории помечаются как untracked, то есть неотслеживаемые. Git «видит», что такой файл существует, но не следит за изменениями в нём. У untracked-файла нет предыдущих версий, зафиксированных в коммитах или через команду git add...
* staged (англ. «подготовленный»)..
После выполнения команды git add файл попадает в staging area (от англ. stage — «сцена», «этап [процесса]» и area — «область»), то есть в список файлов, которые войдут в коммит. В этот момент файл находится в состоянии staged.
В одном из предыдущих уроков мы сравнили коммит с фотографией. Можно развить эту аналогию и сказать, что команда git add добавляет персонажей (текущее содержимое файла или нескольких файлов) на сцену (англ. stage) для общей фотографии, а git commit делает снимок всей сцены целиком...
* tracked (англ. «отслеживаемый»)..
Состояние tracked — это противоположность untracked. Оно довольно широкое по смыслу: в него попадают файлы, которые уже были зафиксированы с помощью git commit, а также файлы, которые были добавлены в staging area командой git add. То есть все файлы, в которых Git так или иначе отслеживает изменения...
modified (англ. «изменённый»)..
Состояние modified означает, что Git сравнил содержимое файла с последней сохранённой версией и нашёл отличия. Например, файл был закоммичен и после этого изменён...
### **Про staged и modified..**
Команда git add добавляет в staging area только текущее содержимое файла. Если вы, например, сделаете git add file.txt, а затем измените file.txt, то новое содержимое файла не будет находиться в staging.
Git сообщит об этом с помощью статуса modified: файл изменён относительно той версии, которая уже в staging. Чтобы добавить в staging последнюю версию, нужно выполнить git add file.txt ещё раз...
### **Типичный жизненный цикл файла в Git..**
1. Файл только что создали. Git про него ещё ничего не знает. Состояние: untracked...
2. Файл добавили в staging area с помощью git add. Состояние: staged (+ tracked)...
* Возможно, изменили файл ещё раз. Состояния: staged, modified (+ tracked)...
* Обратите внимание: staged и modified у одного файла, но у разных его версий...
* Ещё раз выполнили git add. Состояние: staged (+ tracked)...
3. Сделали коммит с помощью git commit. Состояние: tracked...
4. Изменили файл. Состояние: modified (+ tracked)...
5. Снова добавили в staging area с помощью git add. Состояния: staged (+ tracked)...
6. Сделали коммит. Состояния: tracked...
7. Повторили пункты 4−7 много-много раз...
Статусом untracked помечается файл, о существовании которого Git знает, но не следит за изменениями в нём. Этот статус — противоположность tracked, в который попадают все файлы, отслеживаемые Git...
Файл переходит в статус staged после выполнения git add...
Статус modified означает, что файл был изменён...
Большинство файлов в проектах «шагает» по следующему циклу: «изменён» → «добавлен в список на коммит» → «закоммичен» → «изменён» → и так далее.

## **Полезные возможности..**
* Команды необязательно печатать и выполнять по очереди. Можно указать их списком — разделить двумя амперсандами (&&)...
* У консоли есть собственная память — буфер с несколькими последними командами. По ним можно перемещаться с помощью клавиш со стрелками вверх (↑) и вниз (↓)...
* Чтобы не вводить название файла или папки полностью, можно набрать первые символы имени и дважды нажать Tab. Если файл или папка есть в текущей директории, командная строка допишет путь сама.
Например, вы находитесь в папке dev. Начните вводить cd first и дважды нажмите Tab. Если папка first-project есть внутри dev, командная строка автоматически подставит её имя. Останется только нажать Enter.

